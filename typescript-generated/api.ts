// tslint:disable
/**
 * LAB API
 * API spec for LAB API.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Announcement
 */
export interface Announcement {
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    type?: Announcement.TypeEnum;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof Announcement
     */
    recipients?: Array<string>;
}

/**
 * @export
 * @namespace Announcement
 */
export namespace Announcement {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        MAIL = <any> 'MAIL',
        SLACK = <any> 'SLACK'
    }
}

/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * 
     * @type {number}
     * @memberof BadRequest
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof BadRequest
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    sourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    brand?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    last4?: string;
}

/**
 * 
 * @export
 * @interface Door
 */
export interface Door {
    /**
     * 
     * @type {string}
     * @memberof Door
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Door
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Door
     */
    lastPing?: string;
}

/**
 * 
 * @export
 * @interface DoorAction
 */
export interface DoorAction {
    /**
     * 
     * @type {string}
     * @memberof DoorAction
     */
    type?: DoorAction.TypeEnum;
}

/**
 * @export
 * @namespace DoorAction
 */
export namespace DoorAction {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        OPEN = <any> 'OPEN'
    }
}

/**
 * 
 * @export
 * @interface Forbidden
 */
export interface Forbidden {
    /**
     * 
     * @type {number}
     * @memberof Forbidden
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof Forbidden
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {number}
     * @memberof InternalServerError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    stripeCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    status?: Member.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    approved?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    created?: string;
}

/**
 * @export
 * @namespace Member
 */
export namespace Member {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        MEMBER = <any> 'MEMBER',
        SPACEUSER = <any> 'SPACE_USER',
        LEFT = <any> 'LEFT'
    }
}

/**
 * 
 * @export
 * @interface MemberAction
 */
export interface MemberAction {
    /**
     * 
     * @type {string}
     * @memberof MemberAction
     */
    type?: MemberAction.TypeEnum;
}

/**
 * @export
 * @namespace MemberAction
 */
export namespace MemberAction {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        APPROVE = <any> 'APPROVE',
        LEAVE = <any> 'LEAVE'
    }
}

/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * 
     * @type {number}
     * @memberof NotFound
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof NotFound
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface NotImplemented
 */
export interface NotImplemented {
    /**
     * 
     * @type {number}
     * @memberof NotImplemented
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof NotImplemented
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    intervalCount?: number;
}

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    planId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    cancelAtPeriodEnd?: boolean;
}


/**
 * AnnouncementsApi - fetch parameter creator
 * @export
 */
export const AnnouncementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create announcement
         * @summary Create announcement
         * @param {Announcement} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(payload: Announcement, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createAnnouncement.');
            }
            const path = `/announcements`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Delete announcement
         * @summary deletes a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(announcementId: string, options: any = {}): FetchArgs {
            // verify required parameter 'announcementId' is not null or undefined
            if (announcementId === null || announcementId === undefined) {
                throw new RequiredError('announcementId','Required parameter announcementId was null or undefined when calling deleteAnnouncement.');
            }
            const path = `/announcements/{announcementId}/`
                .replace(`{${"announcementId"}}`, String(announcementId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Find announcement
         * @summary Finds a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnouncement(announcementId: string, options: any = {}): FetchArgs {
            // verify required parameter 'announcementId' is not null or undefined
            if (announcementId === null || announcementId === undefined) {
                throw new RequiredError('announcementId','Required parameter announcementId was null or undefined when calling findAnnouncement.');
            }
            const path = `/announcements/{announcementId}/`
                .replace(`{${"announcementId"}}`, String(announcementId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * List announcements
         * @summary List announcements
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/announcements`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create announcement
         * @summary Create announcement
         * @param {Announcement} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(payload: Announcement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Announcement> {
            const fetchArgs = AnnouncementsApiFetchParamCreator(configuration).createAnnouncement(payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete announcement
         * @summary deletes a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(announcementId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = AnnouncementsApiFetchParamCreator(configuration).deleteAnnouncement(announcementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find announcement
         * @summary Finds a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnouncement(announcementId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Announcement> {
            const fetchArgs = AnnouncementsApiFetchParamCreator(configuration).findAnnouncement(announcementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List announcements
         * @summary List announcements
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Announcement>> {
            const fetchArgs = AnnouncementsApiFetchParamCreator(configuration).listAnnouncements(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create announcement
         * @summary Create announcement
         * @param {Announcement} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(payload: Announcement, options?: any) {
            return AnnouncementsApiFp(configuration).createAnnouncement(payload, options)(fetch, basePath);
        },
        /**
         * Delete announcement
         * @summary deletes a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(announcementId: string, options?: any) {
            return AnnouncementsApiFp(configuration).deleteAnnouncement(announcementId, options)(fetch, basePath);
        },
        /**
         * Find announcement
         * @summary Finds a announcement
         * @param {string} announcementId Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnouncement(announcementId: string, options?: any) {
            return AnnouncementsApiFp(configuration).findAnnouncement(announcementId, options)(fetch, basePath);
        },
        /**
         * List announcements
         * @summary List announcements
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAnnouncements(firstResult?: number, maxResults?: number, options?: any) {
            return AnnouncementsApiFp(configuration).listAnnouncements(firstResult, maxResults, options)(fetch, basePath);
        },
    };
};

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * Create announcement
     * @summary Create announcement
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public createAnnouncement(payload: Announcement, options?: any) {
        return AnnouncementsApiFp(this.configuration).createAnnouncement(payload, options)(this.fetch, this.basePath);
    }

    /**
     * Delete announcement
     * @summary deletes a announcement
     * @param {} announcementId Announcement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public deleteAnnouncement(announcementId: string, options?: any) {
        return AnnouncementsApiFp(this.configuration).deleteAnnouncement(announcementId, options)(this.fetch, this.basePath);
    }

    /**
     * Find announcement
     * @summary Finds a announcement
     * @param {} announcementId Announcement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public findAnnouncement(announcementId: string, options?: any) {
        return AnnouncementsApiFp(this.configuration).findAnnouncement(announcementId, options)(this.fetch, this.basePath);
    }

    /**
     * List announcements
     * @summary List announcements
     * @param {} [firstResult] First result
     * @param {} [maxResults] Max results defaults to 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public listAnnouncements(firstResult?: number, maxResults?: number, options?: any) {
        return AnnouncementsApiFp(this.configuration).listAnnouncements(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

}

/**
 * DoorsApi - fetch parameter creator
 * @export
 */
export const DoorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create door
         * @summary Create door
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoor(payload: Door, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createDoor.');
            }
            const path = `/doors`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Create door action
         * @summary Create door action
         * @param {string} doorId Door id
         * @param {DoorAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoorAction(doorId: string, payload: DoorAction, options: any = {}): FetchArgs {
            // verify required parameter 'doorId' is not null or undefined
            if (doorId === null || doorId === undefined) {
                throw new RequiredError('doorId','Required parameter doorId was null or undefined when calling createDoorAction.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createDoorAction.');
            }
            const path = `/doors/{doorId}/actions`
                .replace(`{${"doorId"}}`, String(doorId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Delete door
         * @summary deletes a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoor(doorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'doorId' is not null or undefined
            if (doorId === null || doorId === undefined) {
                throw new RequiredError('doorId','Required parameter doorId was null or undefined when calling deleteDoor.');
            }
            const path = `/doors/{doorId}/`
                .replace(`{${"doorId"}}`, String(doorId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Find door
         * @summary Finds a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDoor(doorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'doorId' is not null or undefined
            if (doorId === null || doorId === undefined) {
                throw new RequiredError('doorId','Required parameter doorId was null or undefined when calling findDoor.');
            }
            const path = `/doors/{doorId}/`
                .replace(`{${"doorId"}}`, String(doorId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * List doors
         * @summary List doors
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDoors(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/doors`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Update door
         * @summary updates a door
         * @param {string} doorId Door id
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoor(doorId: string, payload: Door, options: any = {}): FetchArgs {
            // verify required parameter 'doorId' is not null or undefined
            if (doorId === null || doorId === undefined) {
                throw new RequiredError('doorId','Required parameter doorId was null or undefined when calling updateDoor.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateDoor.');
            }
            const path = `/doors/{doorId}/`
                .replace(`{${"doorId"}}`, String(doorId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * DoorsApi - functional programming interface
 * @export
 */
export const DoorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create door
         * @summary Create door
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoor(payload: Door, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Door> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).createDoor(payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create door action
         * @summary Create door action
         * @param {string} doorId Door id
         * @param {DoorAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoorAction(doorId: string, payload: DoorAction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).createDoorAction(doorId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete door
         * @summary deletes a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoor(doorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).deleteDoor(doorId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find door
         * @summary Finds a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDoor(doorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Door> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).findDoor(doorId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List doors
         * @summary List doors
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDoors(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Door>> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).listDoors(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update door
         * @summary updates a door
         * @param {string} doorId Door id
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoor(doorId: string, payload: Door, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Door> {
            const fetchArgs = DoorsApiFetchParamCreator(configuration).updateDoor(doorId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DoorsApi - factory interface
 * @export
 */
export const DoorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create door
         * @summary Create door
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoor(payload: Door, options?: any) {
            return DoorsApiFp(configuration).createDoor(payload, options)(fetch, basePath);
        },
        /**
         * Create door action
         * @summary Create door action
         * @param {string} doorId Door id
         * @param {DoorAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDoorAction(doorId: string, payload: DoorAction, options?: any) {
            return DoorsApiFp(configuration).createDoorAction(doorId, payload, options)(fetch, basePath);
        },
        /**
         * Delete door
         * @summary deletes a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoor(doorId: string, options?: any) {
            return DoorsApiFp(configuration).deleteDoor(doorId, options)(fetch, basePath);
        },
        /**
         * Find door
         * @summary Finds a door
         * @param {string} doorId Door id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDoor(doorId: string, options?: any) {
            return DoorsApiFp(configuration).findDoor(doorId, options)(fetch, basePath);
        },
        /**
         * List doors
         * @summary List doors
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDoors(firstResult?: number, maxResults?: number, options?: any) {
            return DoorsApiFp(configuration).listDoors(firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Update door
         * @summary updates a door
         * @param {string} doorId Door id
         * @param {Door} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDoor(doorId: string, payload: Door, options?: any) {
            return DoorsApiFp(configuration).updateDoor(doorId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * DoorsApi - object-oriented interface
 * @export
 * @class DoorsApi
 * @extends {BaseAPI}
 */
export class DoorsApi extends BaseAPI {
    /**
     * Create door
     * @summary Create door
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public createDoor(payload: Door, options?: any) {
        return DoorsApiFp(this.configuration).createDoor(payload, options)(this.fetch, this.basePath);
    }

    /**
     * Create door action
     * @summary Create door action
     * @param {} doorId Door id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public createDoorAction(doorId: string, payload: DoorAction, options?: any) {
        return DoorsApiFp(this.configuration).createDoorAction(doorId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Delete door
     * @summary deletes a door
     * @param {} doorId Door id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public deleteDoor(doorId: string, options?: any) {
        return DoorsApiFp(this.configuration).deleteDoor(doorId, options)(this.fetch, this.basePath);
    }

    /**
     * Find door
     * @summary Finds a door
     * @param {} doorId Door id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public findDoor(doorId: string, options?: any) {
        return DoorsApiFp(this.configuration).findDoor(doorId, options)(this.fetch, this.basePath);
    }

    /**
     * List doors
     * @summary List doors
     * @param {} [firstResult] First result
     * @param {} [maxResults] Max results defaults to 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public listDoors(firstResult?: number, maxResults?: number, options?: any) {
        return DoorsApiFp(this.configuration).listDoors(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Update door
     * @summary updates a door
     * @param {} doorId Door id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoorsApi
     */
    public updateDoor(doorId: string, payload: Door, options?: any) {
        return DoorsApiFp(this.configuration).updateDoor(doorId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * MembersApi - fetch parameter creator
 * @export
 */
export const MembersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create member
         * @summary Create member
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(payload: Member, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createMember.');
            }
            const path = `/members`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Create member action
         * @summary Create member action
         * @param {string} memberId Member id
         * @param {MemberAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberAction(memberId: string, payload: MemberAction, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling createMemberAction.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createMemberAction.');
            }
            const path = `/members/{memberId}/actions`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Create card for member
         * @summary creates a card for member
         * @param {string} memberId Member id
         * @param {Card} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberCard(memberId: string, payload: Card, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling createMemberCard.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createMemberCard.');
            }
            const path = `/members/{memberId}/cards`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Create Subscription for member
         * @summary creates a Subscription for member
         * @param {string} memberId Member id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberSubscription(memberId: string, payload: Subscription, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling createMemberSubscription.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createMemberSubscription.');
            }
            const path = `/members/{memberId}/subscriptions`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'POST' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Delete member
         * @summary deletes a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(memberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling deleteMember.');
            }
            const path = `/members/{memberId}`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * deletes card
         * @summary deletes card
         * @param {string} memberId Member id
         * @param {string} cardId Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberCard(memberId: string, cardId: string, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling deleteMemberCard.');
            }
            // verify required parameter 'cardId' is not null or undefined
            if (cardId === null || cardId === undefined) {
                throw new RequiredError('cardId','Required parameter cardId was null or undefined when calling deleteMemberCard.');
            }
            const path = `/members/{memberId}/cards/{cardId}`
                .replace(`{${"memberId"}}`, String(memberId))
                .replace(`{${"cardId"}}`, String(cardId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'DELETE' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Find member
         * @summary Finds a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMember(memberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling findMember.');
            }
            const path = `/members/{memberId}`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Find members cards
         * @summary Lists a members cards
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCards(memberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling findMemberCards.');
            }
            const path = `/members/{memberId}/cards`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Find members subscriptions
         * @summary Lists a members subscriptions
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberSubscriptions(memberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling findMemberSubscriptions.');
            }
            const path = `/members/{memberId}/subscriptions`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * List members
         * @summary List members
         * @param {string} [status] Filter results by member status PENDING, MEMBER, SPACE_USER
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(status?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/members`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            if (status !== undefined) {
                queryParameter['status'] = status;
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * Update member
         * @summary updates a member
         * @param {string} memberId Member id
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(memberId: string, payload: Member, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling updateMember.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateMember.');
            }
            const path = `/members/{memberId}`
                .replace(`{${"memberId"}}`, String(memberId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * updates Subscription
         * @summary updates Subscription
         * @param {string} memberId Member id
         * @param {string} subscriptionId Subscription id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberSubscription(memberId: string, subscriptionId: string, payload: Subscription, options: any = {}): FetchArgs {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling updateMemberSubscription.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling updateMemberSubscription.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateMemberSubscription.');
            }
            const path = `/members/{memberId}/subscriptions/{subscriptionId}`
                .replace(`{${"memberId"}}`, String(memberId))
                .replace(`{${"subscriptionId"}}`, String(subscriptionId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'PUT' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            headerParameter['Content-Type'] = 'application/json';

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);
            requestOptions.body = JSON.stringify(payload || {});

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create member
         * @summary Create member
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(payload: Member, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Member> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).createMember(payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create member action
         * @summary Create member action
         * @param {string} memberId Member id
         * @param {MemberAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberAction(memberId: string, payload: MemberAction, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).createMemberAction(memberId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create card for member
         * @summary creates a card for member
         * @param {string} memberId Member id
         * @param {Card} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberCard(memberId: string, payload: Card, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Card> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).createMemberCard(memberId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create Subscription for member
         * @summary creates a Subscription for member
         * @param {string} memberId Member id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberSubscription(memberId: string, payload: Subscription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).createMemberSubscription(memberId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete member
         * @summary deletes a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(memberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).deleteMember(memberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * deletes card
         * @summary deletes card
         * @param {string} memberId Member id
         * @param {string} cardId Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberCard(memberId: string, cardId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).deleteMemberCard(memberId, cardId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find member
         * @summary Finds a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMember(memberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Member> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).findMember(memberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find members cards
         * @summary Lists a members cards
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCards(memberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Card>> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).findMemberCards(memberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find members subscriptions
         * @summary Lists a members subscriptions
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberSubscriptions(memberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Subscription>> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).findMemberSubscriptions(memberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List members
         * @summary List members
         * @param {string} [status] Filter results by member status PENDING, MEMBER, SPACE_USER
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(status?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Member>> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).listMembers(status, firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update member
         * @summary updates a member
         * @param {string} memberId Member id
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(memberId: string, payload: Member, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Member> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).updateMember(memberId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updates Subscription
         * @summary updates Subscription
         * @param {string} memberId Member id
         * @param {string} subscriptionId Subscription id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberSubscription(memberId: string, subscriptionId: string, payload: Subscription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const fetchArgs = MembersApiFetchParamCreator(configuration).updateMemberSubscription(memberId, subscriptionId, payload, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create member
         * @summary Create member
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(payload: Member, options?: any) {
            return MembersApiFp(configuration).createMember(payload, options)(fetch, basePath);
        },
        /**
         * Create member action
         * @summary Create member action
         * @param {string} memberId Member id
         * @param {MemberAction} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberAction(memberId: string, payload: MemberAction, options?: any) {
            return MembersApiFp(configuration).createMemberAction(memberId, payload, options)(fetch, basePath);
        },
        /**
         * Create card for member
         * @summary creates a card for member
         * @param {string} memberId Member id
         * @param {Card} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberCard(memberId: string, payload: Card, options?: any) {
            return MembersApiFp(configuration).createMemberCard(memberId, payload, options)(fetch, basePath);
        },
        /**
         * Create Subscription for member
         * @summary creates a Subscription for member
         * @param {string} memberId Member id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemberSubscription(memberId: string, payload: Subscription, options?: any) {
            return MembersApiFp(configuration).createMemberSubscription(memberId, payload, options)(fetch, basePath);
        },
        /**
         * Delete member
         * @summary deletes a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(memberId: string, options?: any) {
            return MembersApiFp(configuration).deleteMember(memberId, options)(fetch, basePath);
        },
        /**
         * deletes card
         * @summary deletes card
         * @param {string} memberId Member id
         * @param {string} cardId Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberCard(memberId: string, cardId: string, options?: any) {
            return MembersApiFp(configuration).deleteMemberCard(memberId, cardId, options)(fetch, basePath);
        },
        /**
         * Find member
         * @summary Finds a member
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMember(memberId: string, options?: any) {
            return MembersApiFp(configuration).findMember(memberId, options)(fetch, basePath);
        },
        /**
         * Find members cards
         * @summary Lists a members cards
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCards(memberId: string, options?: any) {
            return MembersApiFp(configuration).findMemberCards(memberId, options)(fetch, basePath);
        },
        /**
         * Find members subscriptions
         * @summary Lists a members subscriptions
         * @param {string} memberId Member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberSubscriptions(memberId: string, options?: any) {
            return MembersApiFp(configuration).findMemberSubscriptions(memberId, options)(fetch, basePath);
        },
        /**
         * List members
         * @summary List members
         * @param {string} [status] Filter results by member status PENDING, MEMBER, SPACE_USER
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(status?: string, firstResult?: number, maxResults?: number, options?: any) {
            return MembersApiFp(configuration).listMembers(status, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Update member
         * @summary updates a member
         * @param {string} memberId Member id
         * @param {Member} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(memberId: string, payload: Member, options?: any) {
            return MembersApiFp(configuration).updateMember(memberId, payload, options)(fetch, basePath);
        },
        /**
         * updates Subscription
         * @summary updates Subscription
         * @param {string} memberId Member id
         * @param {string} subscriptionId Subscription id
         * @param {Subscription} payload Payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberSubscription(memberId: string, subscriptionId: string, payload: Subscription, options?: any) {
            return MembersApiFp(configuration).updateMemberSubscription(memberId, subscriptionId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * Create member
     * @summary Create member
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMember(payload: Member, options?: any) {
        return MembersApiFp(this.configuration).createMember(payload, options)(this.fetch, this.basePath);
    }

    /**
     * Create member action
     * @summary Create member action
     * @param {} memberId Member id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMemberAction(memberId: string, payload: MemberAction, options?: any) {
        return MembersApiFp(this.configuration).createMemberAction(memberId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Create card for member
     * @summary creates a card for member
     * @param {} memberId Member id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMemberCard(memberId: string, payload: Card, options?: any) {
        return MembersApiFp(this.configuration).createMemberCard(memberId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Create Subscription for member
     * @summary creates a Subscription for member
     * @param {} memberId Member id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMemberSubscription(memberId: string, payload: Subscription, options?: any) {
        return MembersApiFp(this.configuration).createMemberSubscription(memberId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Delete member
     * @summary deletes a member
     * @param {} memberId Member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(memberId: string, options?: any) {
        return MembersApiFp(this.configuration).deleteMember(memberId, options)(this.fetch, this.basePath);
    }

    /**
     * deletes card
     * @summary deletes card
     * @param {} memberId Member id
     * @param {} cardId Card id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMemberCard(memberId: string, cardId: string, options?: any) {
        return MembersApiFp(this.configuration).deleteMemberCard(memberId, cardId, options)(this.fetch, this.basePath);
    }

    /**
     * Find member
     * @summary Finds a member
     * @param {} memberId Member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMember(memberId: string, options?: any) {
        return MembersApiFp(this.configuration).findMember(memberId, options)(this.fetch, this.basePath);
    }

    /**
     * Find members cards
     * @summary Lists a members cards
     * @param {} memberId Member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberCards(memberId: string, options?: any) {
        return MembersApiFp(this.configuration).findMemberCards(memberId, options)(this.fetch, this.basePath);
    }

    /**
     * Find members subscriptions
     * @summary Lists a members subscriptions
     * @param {} memberId Member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberSubscriptions(memberId: string, options?: any) {
        return MembersApiFp(this.configuration).findMemberSubscriptions(memberId, options)(this.fetch, this.basePath);
    }

    /**
     * List members
     * @summary List members
     * @param {} [status] Filter results by member status PENDING, MEMBER, SPACE_USER
     * @param {} [firstResult] First result
     * @param {} [maxResults] Max results defaults to 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMembers(status?: string, firstResult?: number, maxResults?: number, options?: any) {
        return MembersApiFp(this.configuration).listMembers(status, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Update member
     * @summary updates a member
     * @param {} memberId Member id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public updateMember(memberId: string, payload: Member, options?: any) {
        return MembersApiFp(this.configuration).updateMember(memberId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * updates Subscription
     * @summary updates Subscription
     * @param {} memberId Member id
     * @param {} subscriptionId Subscription id
     * @param {} payload Payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public updateMemberSubscription(memberId: string, subscriptionId: string, payload: Subscription, options?: any) {
        return MembersApiFp(this.configuration).updateMemberSubscription(memberId, subscriptionId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductsApi - fetch parameter creator
 * @export
 */
export const ProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List product plans
         * @summary List product plans
         * @param {string} productId product id
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPlans(productId: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling listProductPlans.');
            }
            const path = `/products/{productId}/plans`
                .replace(`{${"productId"}}`, String(productId));
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
        /**
         * List products
         * @summary List products
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const path = `/products`;
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: 'GET' }, options);
            const headerParameter = {} as any;
            const queryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const apiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                headerParameter["Authorization"] = apiKeyValue;
            }

            if (firstResult !== undefined) {
                queryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                queryParameter['maxResults'] = maxResults;
            }

            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete urlObj.search;
            requestOptions.headers = Object.assign({}, headerParameter, options.headers);

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List product plans
         * @summary List product plans
         * @param {string} productId product id
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPlans(productId: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Plan>> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).listProductPlans(productId, firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List products
         * @summary List products
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
            const fetchArgs = ProductsApiFetchParamCreator(configuration).listProducts(firstResult, maxResults, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List product plans
         * @summary List product plans
         * @param {string} productId product id
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPlans(productId: string, firstResult?: number, maxResults?: number, options?: any) {
            return ProductsApiFp(configuration).listProductPlans(productId, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * List products
         * @summary List products
         * @param {number} [firstResult] First result
         * @param {number} [maxResults] Max results defaults to 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(firstResult?: number, maxResults?: number, options?: any) {
            return ProductsApiFp(configuration).listProducts(firstResult, maxResults, options)(fetch, basePath);
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * List product plans
     * @summary List product plans
     * @param {} productId product id
     * @param {} [firstResult] First result
     * @param {} [maxResults] Max results defaults to 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductPlans(productId: string, firstResult?: number, maxResults?: number, options?: any) {
        return ProductsApiFp(this.configuration).listProductPlans(productId, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * List products
     * @summary List products
     * @param {} [firstResult] First result
     * @param {} [maxResults] Max results defaults to 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(firstResult?: number, maxResults?: number, options?: any) {
        return ProductsApiFp(this.configuration).listProducts(firstResult, maxResults, options)(this.fetch, this.basePath);
    }

}

